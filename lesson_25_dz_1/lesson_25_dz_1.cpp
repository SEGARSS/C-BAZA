//Заполнить массив случайными числами. Генератор уникальных случайных чисел. rand. srand ДЗ #7 - Видео 38. 

/*
Заполнить массив случайными числами Размер массива 10 и случайные числа до 20.
И чтобы числа не повторялись.
*/

#include<iostream>
#include<ctime> 
using namespace std;

void main()
{
	setlocale(LC_ALL, "ru");
	srand(time(NULL));	   

	const int SIZE = 10; 
	int arr[SIZE];		
	bool already; //Переменная которая будет проверять, есть такое число уже в массиве или нет.   

	for (int i = 0; i < SIZE; )			
	{
		already = false;			  //Мы предпологаем сразу, что такой переменной нет заранее.
		int ranom = rand() % 20;

		for (int j = 0; j < i; j++)	//Проверка нашего масива, на наличие уже одинаковых элементо.
		{
			if (arr[j] == ranom) 
			{
				already = true;
				break;
			}
		}

		if (already != true)
		{
			arr[i] = ranom; //в нашь масив попадает переменная, сгенерированная случайное число.
			i++;
		}
	}

	for (int i = 0; i < SIZE; i++) 
		cout << arr[i] << endl;
}

/*
По написанному коду, все изначально рандомнеы числа попадают сначала в arr[j], по данному условию - arr[j] == ranom.
далее, arr[j] пробигается по arr[i], если к примеру это первая интерация, то получив число, сразу сработает проверка
already = false, так как в первой интерации в arr[i] под нулевым индексом находиться мусор, и нет числа, поэтому
первое число попадаёт в любом случаи в нулевой индекс arr[i] по данному условию already != true делее arr[i] = ranom и после это
запускаем вторую интерацию благодаря i++. 
break; для того, чтобы после проверки, не важно найдём ли одинаковое число или нет, он не проверял дальше выше положенного цикла,
тоесть все 10, смысла нет, так как там пока муссор. Проверка будет иди по той отерации под которой сейчас прибавился индекс i и j.
*/

/*
Проверят, есть ли уже в масиве такая переменная, тоесть, j это
уже весь масив на момент проверки, и он смотрит с сравнивает(проверяет ranom)
с полученной новой переменное, присутствует ли такая уже в масиве. с если да, то становиться true, то значит
мы не должны добавлять её в масив. Поэтому сработает break, ниже мы по циклу не идём, и начинаем цикл for заново.
Если ещё проще. arr[j] == ranom, тоесть, по счётчику j в цикле for, это переберание всех элементов
всех элментов уже присутствующих в масиве, и сравнивает их сразу с новой, рандомной переменной.
Если в масиве к примеру попалась 5, и новая случайная переменная тоже 5, то и вышло условие
arr[j] == ranom. А значит, ниже по циклам мы не идём, начинаеться break. И прыгаем обратно в самое
Начало циклов, чтобы получить новую переменную.			
*/

/*
Когда мы проверяем, что не должно быть равно true, тоесть, выше условие проверило, что такая переменная
уже присутствует в масиве, и присвоило значение true. И дойдят до цикла где условие не должно быть равно true
условие цикло отрабатываться не будет, данная переменная не войдёт в масив, и мы прыгни на самое начало цикла,
для получения новой переменной.
*/

/*
Подытожить. Цикл for со значение i, должен крутить условие до 10, это его основная задача, чтоб не уйти в бесконечность.
А цикл for со значением j проверяет уже элементы попавшие в сам масив, проверяет для того, что там не стало одинаковых
элементов.
*/