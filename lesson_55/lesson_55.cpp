//Приведение типов в стиле с. Явное и неявное преобразование типов. Преобразование типов. С++ Урок #61 - Видео №73.

#include<iostream>
using namespace std;

void main()
{
	setlocale(LC_ALL, "ru");

	//Явное и не явное преобразование данных.

	/*
	Мы приводим пример явного преобразование данных. А именно. Объявив переменную double a, компелятору
	явно указываем что хотим получить с неё переменную типа int - cout << (int)a << endl; Это явное указывание. 
	*/
	cout << "Явное указываение" << endl;
	double a = 33.3;
	cout << (int)a << endl;
	cout << "==============" << endl << endl;

	/*
	Не явное уазывание, компелятор за нас преобразует данные. Потомучто переменную (v) типа double мы присваем
	в переменную f типа int.
	*/
	cout << "Не явное указываение" << endl;
	double v = 33.3;
	int f = v;
	cout << f << endl;
	cout << "==============" << endl << endl;

	//Тип сужающие или расщиряющие методы

	/*
	Данный пример расширение, мы перементу int ложим в переменную типа double. По принципу, мы меньшее ложим
	в большое, так как тип double может хранить в себе больше значений(дробные) нежели чем тип int. В таком
	случаи, любые потери данных могут быть исключенны.
	*/
	cout << "Расширяющий" << endl;
	int p = 33.4846;
	double r = p;
	cout << p << endl;
	cout << "==============" << endl << endl;

	/*
	Сужение, мы переменную типа double ложим в переменую типа int - которая сама по себе может меньше хранить
	данных(она уже к примеру отрежит данные дробной части) Плюс, при сужающимся типе, может произойти потеря
	данных. (бонально дробная часть откинулась и больше не задествовалась).
	*/
	cout << "Сужение" << endl;
	double h = 33.4846;
	int j = h;
	cout << j << endl;
	cout << "==============" << endl << endl;

	//Компелятор, всегда стараеться избежать потерю данных

	/*
	Если мы указываем, поработать с данными типа int и double то на выводе, компелятор, всегда и стандартно
	покажет полную картину типа данных без потерь, если мы конечно же явно ему что-то не указали.
	А мы прост оуказали cout << e / t << endl; и в этоге получили полную картину дробного числа, так как оно там
	пристуствует. Соотвественно компелятор стандартно будет делат всё чтоб не потерять данные.
	Или по простому, компелятор будет всегда приводить к наиболее большому типу данных, чтобы собственно избежать
	потерю данных.
	*/
	cout << "Работа компелятора стандартная" << endl;
	int e = 33;
	double t = 442.56;
	cout << e * t << endl;
	cout << "==============" << endl << endl;
}