//Рекурсия. Факториал числа c++ рекурсивно. Рекурсия факториал. Рекурсивный алгоритм факториал. #44 - Видео №54

#include<iostream>
using namespace std;

/*
* ! - Данный знак, по формуле обозначает факториал, где N любое число.
Для примера, как вычисляеться факториал числа 3? Сначала прописываем 3!=3*(3-1)!, но чтобы нам умножить 3*(3-1)!
надо вычеслить и само выражение факториала (3-1)!, а это значит, дальше по условию пишем 2!=2*(2-1)!, потомучто
по преведущему условию 3-1=2, и теперь 2 нужно найти его факториал и спускаемся ниже 1!=1, а факториал 1 всегда будет
1 и тоже самое факториал 0 всегда будит 0. 
И на примере стека, мы в самый низ поместили условие которое первое начали выполнять, это 3!=3*(3-1)!, затем 2!=2*(2-1)!
и затем это 1!=1. И теперь идём обратно, то что посложили последним, с него и начинаем. Возвращаем 1, и теперь 
умножаем 1 на 2 по условию 2!=2*(2-1)!, получили 2, возвращаем 2 и умножаем на 3 по условию 3!=3*(3-1)! и получаем
факториал числа 3 = 6. Таким образом, функцию которую положили в стек первую, к ней дошли в само конце.
    N! = N * (N-1)!
	3!=3*(3-1)!
	2!=2*(2-1)!
	1!=1
	
*/

/*Пример уже закодированный, вычисления факториала 5. Едиственное, добавили, выход из цикла чтоб небыл бесконечный.*/
int Fact(int N)// Обозначение Fact и есть - !.
{
	if (N == 0)// Один выход, еси факторил станет 0
		return 0;
	if (N == 1)//Второй выход , факторила 1 = 1.
		return 1;
	return N * Fact(N - 1);
	/*Несовсем тольок понял, зачем выход с 0 и с 1 делать, когда достаточно 1. Но проверил, если оставить только
	0, то по данной формуле тольк 0 всегда и будет, а если оставить только 1 то всё получаеться и работает.
	Наверное это закономерность формулы.*/
}

void main()
{
	setlocale(LC_ALL, "Rus");

	cout << Fact(5) << endl;
}